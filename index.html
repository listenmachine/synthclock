<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hour Drift — Minimal Time Gradient</title>
<meta name="color-scheme" content="dark light" />
<style>
  :root{
    --fg: #eaeaea;
    --panel: rgb(28 28 30 / 88%);
    --shadow: 0 8px 24px rgb(0 0 0 / 35%);
    --grain-opacity: .15; /* fixed 15% */
  }
  html,body{height:100%}
  body{
    margin:0; height:100%;
    background:#0b0b0c;                    /* replaced by gradient image */
    color:var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-size: auto auto;            /* image drawn at 1:1 CSS pixels */
    will-change: background-position;      /* GPU hint for ultra-smooth slide */
    overflow:hidden;
  }

  /* Grain overlay (static, smaller tile) */
  .grain{
    position:fixed; inset:0; z-index:2; pointer-events:none;
    mix-blend-mode: soft-light; opacity: var(--grain-opacity);
    background-repeat: repeat; background-size: auto;
  }

  /* Minimal UI */
  .brand{
    position:fixed; left:18px; top:20px; font-weight:700; opacity:.85;
    text-shadow: 0 2px 12px rgb(0 0 0 / .45); z-index:5;
  }
  .topbar{
    position:fixed; top:18px; right:18px; display:flex; gap:10px; z-index:5;
    filter: drop-shadow(0 6px 18px rgb(0 0 0 / .35));
  }
  .btn{ background:#1b1b1d; color:var(--fg); border:1px solid #333; padding:10px 14px; border-radius:14px; cursor:pointer; font-weight:600; letter-spacing:.2px; }
  .btn:hover{ filter:brightness(1.1) }

  /* Settings */
  dialog{
    border:none; border-radius:22px; padding:0; background:var(--panel); color:var(--fg);
    width:min(760px, 92vw); box-shadow: var(--shadow);
  }
  dialog::backdrop{ background: rgb(0 0 0 / .45) }
  .panel{ padding:18px }
  .panel h2{ margin:4px 0 14px; font-size:1.05rem; letter-spacing:.3px; }
  .grid{ display:grid; grid-template-columns: repeat(6,minmax(0,1fr)); gap:10px; }
  .sw{ background:#141416; border:1px solid #2d2e33; border-radius:12px; padding:8px; display:flex; flex-direction:column; align-items:center; gap:6px; }
  .sw label{ font-size:.8rem; opacity:.8; font-weight:600 }
  .sw input[type="color"]{ width:100%; height:38px; border:none; background:transparent; border-radius:10px; cursor:pointer; }
  @media (max-width:760px){ .grid{ grid-template-columns: repeat(3,minmax(0,1fr)); } }

  /* Tiny build tag */
  .version{position:fixed; right:14px; bottom:14px; font: 12px/1.2 ui-sans-serif,system-ui; opacity:.35}
</style>
</head>
<body>
  <div class="brand">Hour Drift</div>
  <div class="topbar">
    <button class="btn" id="open">Colours</button>
  </div>

  <!-- Grain overlay -->
  <div class="grain" id="grain" aria-hidden="true"></div>
  <div class="version" id="ver"></div>

  <!-- Settings (only colour selectors) -->
  <dialog id="panel">
    <div class="panel">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <h2>Hour colours (1–12)</h2>
        <button class="btn" id="close">Close</button>
      </div>
      <div class="grid" id="swGrid"></div>
    </div>
  </dialog>

<script>
/* ===== Build tag ===== */
const BUILD = 'minimal-smooth-v12';
document.getElementById('ver').textContent = BUILD;

/* ===== State (only colours 1–12; always 12-hour) ===== */
const DEFAULTS = {
  hours: [
    '#ffdf43', '#1e49ff', '#4bd964', '#34c0ff', '#9b59ff', '#ff9bd3',
    '#ff7e33', '#16c6a8', '#c6ff34', '#d96a7f', '#ff5a5f', '#e2902f'
  ]
};
const store = {
  load(){ try{ return JSON.parse(localStorage.getItem('hourDrift_min')) || DEFAULTS }catch{ return DEFAULTS } },
  save(s){ localStorage.setItem('hourDrift_min', JSON.stringify(s)); }
};
let state = store.load();

/* ===== DOM ===== */
const openBtn  = document.getElementById('open');
const panel    = document.getElementById('panel');
const closeBtn = document.getElementById('close');
const grid     = document.getElementById('swGrid');
const grainDiv = document.getElementById('grain');

/* ===== UI (only swatches) ===== */
function buildSwatches(){
  grid.innerHTML = '';
  for(let i=1;i<=12;i++){
    const wrap = document.createElement('div'); wrap.className='sw';
    const lab = document.createElement('label'); lab.textContent = i;
    const inp = document.createElement('input'); inp.type='color'; inp.value = state.hours[i-1];
    inp.addEventListener('input', e => { state.hours[i-1]=e.target.value; store.save(state); regenGradient(); });
    wrap.append(lab, inp); grid.appendChild(wrap);
  }
}
openBtn.onclick = ()=>{ buildSwatches(); panel.showModal(); };
closeBtn.onclick = ()=> panel.close();

/* ===== Grain (static, small tile) ===== */
function renderGrain(){
  const size = 64;                                // smaller grain
  const c = document.createElement('canvas'); c.width = size; c.height = size;
  const ctx = c.getContext('2d', { willReadFrequently: true });
  const id = ctx.createImageData(size, size); const data = id.data;
  for(let i=0;i<data.length;i+=4){
    const v = (Math.random()*255)|0;
    data[i]=data[i+1]=data[i+2]=v; data[i+3]=255;
  }
  ctx.putImageData(id,0,0);
  grainDiv.style.backgroundImage = `url(${c.toDataURL()})`;
}

/* ===== Colour math (OKLCH “pretty” blend, no UI) ===== */
function srgbToLinear(u){ u/=255; return u<=0.04045 ? u/12.92 : Math.pow((u+0.055)/1.055, 2.4); }
function linearToSrgb(u){ return u<=0.0031308 ? 12.92*u : 1.055*Math.pow(u,1/2.4)-0.055; }
function clamp01(x){ return Math.min(1, Math.max(0, x)); }
function hexToRgb(hex){ const h=hex.replace('#',''); const v=h.length===3?h.split('').map(x=>x+x).join(''):h; return { r:parseInt(v.slice(0,2),16), g:parseInt(v.slice(2,4),16), b:parseInt(v.slice(4,6),16) }; }
function rgbToHex(r,g,b){ const toHex=v=>('0'+Math.round(v).toString(16)).slice(-2); return '#'+toHex(r)+toHex(g)+toHex(b); }
function rgbToOklab(r8,g8,b8){
  const r=srgbToLinear(r8), g=srgbToLinear(g8), b=srgbToLinear(b8);
  const l=0.4122214708*r+0.5363325363*g+0.0514459929*b;
  const m=0.2119034982*r+0.6806995451*g+0.1073969566*b;
  const s=0.0883024619*r+0.2817188376*g+0.6299787005*b;
  const l_ = Math.cbrt(l), m_ = Math.cbrt(m), s_ = Math.cbrt(s);
  return {
    L: 0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,
    a: 1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,
    b: 0.0259040371*l_ + 0.7827717662*s_ - 0.8086757660*m_
  };
}
function oklabToRgb(L,a,b){
  const l_ = Math.pow(L + 0.3963377774*a + 0.2158037573*b, 3);
  const m_ = Math.pow(L - 0.1055613458*a - 0.0638541728*b, 3);
  const s_ = Math.pow(L - 0.0894841775*a - 1.2914855480*b, 3);
  const r =  4.0767416621*l_ - 3.3077115913*m_ + 0.2309699292*s_;
  const g = -1.2684380046*l_ + 2.6097574011*m_ - 0.3413193965*s_;
  const bl= 0.0041960863*l_ - 0.7034186147*m_ + 1.6990625617*s_;
  return { r:Math.round(clamp01(linearToSrgb(r))*255),
           g:Math.round(clamp01(linearToSrgb(g))*255),
           b:Math.round(clamp01(linearToSrgb(bl))*255) };
}
function oklabToOklch(L,a,b){
  const C = Math.hypot(a,b); let h = Math.atan2(b,a)*180/Math.PI; if(h<0) h+=360; return {L,C,h};
}
function oklchToOklab(L,C,h){ const hr=h*Math.PI/180; return {L, a:C*Math.cos(hr), b:C*Math.sin(hr)}; }
function hueDelta(h1,h2){ const diff = ((h2 - h1 + 540) % 360) - 180; return diff; } // shortest path
function mixOKLCHPretty(c1,c2,t){
  const A=hexToRgb(c1), B=hexToRgb(c2);
  const aLab=rgbToOklab(A.r,A.g,A.b), bLab=rgbToOklab(B.r,B.g,B.b);
  const a=oklabToOklch(aLab.L, aLab.a, aLab.b), b=oklabToOklch(bLab.L, bLab.a, bLab.b);

  const dh = hueDelta(a.h, b.h);
  const bell = Math.sin(Math.PI * t);     // 0→1→0
  const ss = t*t*(3 - 2*t);               // smoothstep for L

  // Fixed “pretty” shaping
  const L = a.L + (b.L - a.L)*ss + (0.08)*bell;   // +8% mid lift
  const C = a.C + (b.C - a.C)*t  + (0.24)*bell;   // +24% mid chroma
  const h = (a.h + dh*t + 360) % 360;

  const lab = oklchToOklab(L,C,h);
  const rgb = oklabToRgb(lab.L, lab.a, lab.b);
  return rgbToHex(rgb.r, rgb.g, rgb.b);
}

/* ===== Gradient image (pre-rendered) ===== */
let gradDataUrl = null;
let gradWidth = 0, gradHeight = 0, imgHalf = 0, bandPx = 0;

/* Create an off-screen canvas gradient (centered), sized to always cover the viewport
   while we slide it from full right → full left smoothly. */
function makeGradientImage(cNow, cNext){
  const vw = Math.max(1, window.innerWidth);
  const vh = Math.max(1, window.innerHeight);

  gradWidth  = Math.round(vw * 2.2);      // >= 2× viewport width → full coverage at extremes
  gradHeight = vh;                        // draw at 1:1 CSS pixels
  imgHalf    = gradWidth / 2;
  bandPx     = Math.max(12, Math.round(vw * 0.30)); // ~30% of screen width

  const c = document.createElement('canvas');
  c.width = gradWidth; c.height = gradHeight;
  const ctx = c.getContext('2d');

  // Draw horizontal strip by columns
  const leftSolid  = new Path2D(); leftSolid.rect(0, 0, imgHalf - bandPx/2, gradHeight);
  ctx.fillStyle = cNow; ctx.fill(leftSolid);

  const rightSolid = new Path2D(); rightSolid.rect(imgHalf + bandPx/2, 0, gradWidth, gradHeight);
  ctx.fillStyle = cNext; ctx.fill(rightSolid);

  // Blend band (sampled)
  const xStart = Math.floor(imgHalf - bandPx/2);
  const xEnd   = Math.ceil(imgHalf + bandPx/2);
  for(let x = xStart; x <= xEnd; x++){
    const t = (x - xStart) / Math.max(1, (xEnd - xStart));
    ctx.fillStyle = mixOKLCHPretty(cNow, cNext, t);
    ctx.fillRect(x, 0, 1, gradHeight);
  }

  gradDataUrl = c.toDataURL();
  document.body.style.backgroundImage = `url(${gradDataUrl})`;
  document.body.style.backgroundSize  = `${gradWidth}px ${gradHeight}px`;
}

/* ===== Time mapping & smooth slide ===== */
function h12(h){ const v = h % 12; return v===0 ? 12 : v; }
function hourColor(hour){ return state.hours[(hour-1+12)%12] || '#ffffff'; }

let lastPairKey = '';
function regenGradient(){
  const now = new Date();
  const cur = h12(now.getHours());
  const next = cur % 12 + 1;
  const key = cur + '>' + next + ':' + hourColor(cur) + '→' + hourColor(next);
  if(key !== lastPairKey){
    makeGradientImage(hourColor(cur), hourColor(next));
    lastPairKey = key;
  }
}

function slideLoop(){
  const now = new Date();
  const vh = window.innerHeight; // not used, but keeps layout cached
  const vw = window.innerWidth;

  // progress across the hour, 0→1
  const t = ((now.getMinutes()*60 + now.getSeconds())*1000 + now.getMilliseconds()) / 3600000;

  // desired center on screen (right→left)
  const desiredCenter = (1 - t) * vw;                // px from left edge
  const leftOffset = Math.round(desiredCenter - imgHalf);

  // move the pre-rendered image with sub-pixel precision
  document.body.style.backgroundPosition = `${leftOffset}px 0px`;

  // if the hour rolled over (or colours changed), rebuild the image
  regenGradient();

  requestAnimationFrame(slideLoop);
}

/* ===== Resize handling ===== */
let resizeTimer=null;
function onResize(){
  if(resizeTimer) cancelAnimationFrame(resizeTimer);
  resizeTimer = requestAnimationFrame(()=>{ lastPairKey=''; regenGradient(); });
}

/* ===== Boot ===== */
renderGrain();
regenGradient();
slideLoop();
addEventListener('resize', onResize);
</script>
</body>
</html>
