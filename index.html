<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hour Drift — Minimal Time Gradient</title>
<meta name="color-scheme" content="dark light" />
<style>
  :root{
    --fg: #eaeaea;
    --panel: rgb(28 28 30 / 88%);
    --shadow: 0 8px 24px rgb(0 0 0 / 10%);
    --grain-opacity: .05; /* fixed 5% */
  }
  html,body{height:100%}
  body{
    margin:0; height:100%;
    background:#0b0b0c;                    /* replaced by gradient image */
    color:var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-size: auto auto;            /* 1:1 CSS pixels */
    will-change: background-position;      /* very smooth slide */
    overflow:hidden;
  }

  /* Grain overlay (static, small tile) */
  .grain{
    position:fixed; inset:0; z-index:2; pointer-events:none;
    mix-blend-mode: soft-light; opacity: var(--grain-opacity);
    background-repeat: repeat; background-size: auto;
  }

  /* Minimal UI */
  .brand{
    position:fixed; left:18px; top:20px; font-weight:700; opacity:.85;
    text-shadow: 0 2px 12px rgb(0 0 0 / .45); z-index:5;
  }
  .topbar{
    position:fixed; top:18px; right:18px; display:flex; gap:10px; z-index:5;
    filter: drop-shadow(0 6px 18px rgb(0 0 0 / .35));
  }
  .btn{ background:#1b1b1d; color:var(--fg); border:1px solid #333; padding:10px 14px; border-radius:14px; cursor:pointer; font-weight:600; letter-spacing:.2px; }
  .btn:hover{ filter:brightness(1.1) }

  /* Settings */
  dialog{
    border:none; border-radius:22px; padding:0; background:var(--panel); color:var(--fg);
    width:min(760px, 92vw); box-shadow: var(--shadow);
  }
  dialog::backdrop{ background: rgb(0 0 0 / .45) }
  .panel{ padding:18px }
  .panel h2{ margin:4px 0 14px; font-size:1.05rem; letter-spacing:.3px; }
  .grid{ display:grid; grid-template-columns: repeat(6,minmax(0,1fr)); gap:10px; }
  .sw{ background:#141416; border:1px solid #2d2e33; border-radius:12px; padding:8px; display:flex; flex-direction:column; align-items:center; gap:6px; }
  .sw label{ font-size:.8rem; opacity:.8; font-weight:600 }
  .sw input[type="color"]{ width:100%; height:38px; border:none; background:transparent; border-radius:10px; cursor:pointer; }
  @media (max-width:760px){ .grid{ grid-template-columns: repeat(3,minmax(0,1fr)); } }

  .version{position:fixed; right:14px; bottom:14px; font: 12px/1.2 ui-sans-serif,system-ui; opacity:.35}
</style>
</head>
<body>
  <div class="brand">Hour Drift</div>
  <div class="topbar">
    <button class="btn" id="open">Colours</button>
  </div>

  <!-- Grain overlay -->
  <div class="grain" id="grain" aria-hidden="true"></div>
  <div class="version" id="ver"></div>

  <!-- Settings (only colour selectors) -->
  <dialog id="panel">
    <div class="panel">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <h2>Hour colours (1–12)</h2>
        <button class="btn" id="close">Close</button>
      </div>
      <div class="grid" id="swGrid"></div>
    </div>
  </dialog>

<script>
/* ===== Build tag ===== */
const BUILD = 'minimal-srgb-v13';
document.getElementById('ver').textContent = BUILD;

/* ===== State (only colours 1–12; always 12-hour) ===== */
const DEFAULTS = {
  hours: [
    '#ffdf43', '#1e49ff', '#4bd964', '#34c0ff', '#9b59ff', '#ff9bd3',
    '#ff7e33', '#16c6a8', '#c6ff34', '#d96a7f', '#ff5a5f', '#e2902f'
  ]
};
const store = {
  load(){ try{ return JSON.parse(localStorage.getItem('hourDrift_min')) || DEFAULTS }catch{ return DEFAULTS } },
  save(s){ localStorage.setItem('hourDrift_min', JSON.stringify(s)); }
};
let state = store.load();

/* ===== DOM ===== */
const openBtn  = document.getElementById('open');
const panel    = document.getElementById('panel');
const closeBtn = document.getElementById('close');
const grid     = document.getElementById('swGrid');
const grainDiv = document.getElementById('grain');

/* ===== UI (only swatches) ===== */
function buildSwatches(){
  grid.innerHTML = '';
  for(let i=1;i<=12;i++){
    const wrap = document.createElement('div'); wrap.className='sw';
    const lab = document.createElement('label'); lab.textContent = i;
    const inp = document.createElement('input'); inp.type='color'; inp.value = state.hours[i-1];
    inp.addEventListener('input', e => { state.hours[i-1]=e.target.value; store.save(state); regenGradient(); });
    wrap.append(lab, inp); grid.appendChild(wrap);
  }
}
openBtn.onclick = ()=>{ buildSwatches(); panel.showModal(); };
closeBtn.onclick = ()=> panel.close();

/* ===== Grain (static, small tile) ===== */
function renderGrain(){
  const size = 64;                                // smaller grain
  const c = document.createElement('canvas'); c.width = size; c.height = size;
  const ctx = c.getContext('2d', { willReadFrequently: true });
  const id = ctx.createImageData(size, size); const data = id.data;
  for(let i=0;i<data.length;i+=4){
    const v = (Math.random()*255)|0;
    data[i]=data[i+1]=data[i+2]=v; data[i+3]=255;
  }
  ctx.putImageData(id,0,0);
  grainDiv.style.backgroundImage = `url(${c.toDataURL()})`;
}

/* ===== Simple sRGB blend (like the original CSS gradient) ===== */
function hexToRgb(hex){ const h=hex.replace('#',''); const v=h.length===3?h.split('').map(x=>x+x).join(''):h; return { r:parseInt(v.slice(0,2),16), g:parseInt(v.slice(2,4),16), b:parseInt(v.slice(4,6),16) }; }
function rgbToHex(r,g,b){ const toHex=v=>('0'+Math.round(v).toString(16)).slice(-2); return '#'+toHex(r)+toHex(g)+toHex(b); }
function mixSRGB(c1,c2,t){
  const a=hexToRgb(c1), b=hexToRgb(c2);
  const r=a.r+(b.r-a.r)*t, g=a.g+(b.g-a.g)*t, bl=a.b+(b.b-a.b)*t;
  return rgbToHex(r,g,bl);
}

/* ===== Gradient image (pre-rendered, then we slide it) ===== */
let gradDataUrl = null;
let gradWidth = 0, gradHeight = 0, imgHalf = 0, bandPx = 0;

function makeGradientImage(cNow, cNext){
  const vw = Math.max(1, window.innerWidth);
  const vh = Math.max(1, window.innerHeight);

  gradWidth  = Math.round(vw * 2.2);      // >= 2× viewport width → coverage at extremes
  gradHeight = vh;
  imgHalf    = gradWidth / 2;
  bandPx     = Math.max(12, Math.round(vw * 0.30)); // ~30% of screen width

  const c = document.createElement('canvas');
  c.width = gradWidth; c.height = gradHeight;
  const ctx = c.getContext('2d');

  // Left/right solids
  ctx.fillStyle = cNow;  ctx.fillRect(0, 0, imgHalf - bandPx/2, gradHeight);
  ctx.fillStyle = cNext; ctx.fillRect(imgHalf + bandPx/2, 0, gradWidth, gradHeight);

  // sRGB blend band
  const xStart = Math.floor(imgHalf - bandPx/2);
  const xEnd   = Math.ceil(imgHalf + bandPx/2);
  for(let x = xStart; x <= xEnd; x++){
    const t = (x - xStart) / Math.max(1, (xEnd - xStart));
    ctx.fillStyle = mixSRGB(cNow, cNext, t);
    ctx.fillRect(x, 0, 1, gradHeight);
  }

  gradDataUrl = c.toDataURL();
  document.body.style.backgroundImage = `url(${gradDataUrl})`;
  document.body.style.backgroundSize  = `${gradWidth}px ${gradHeight}px`;
}

/* ===== Time mapping & smooth slide ===== */
function h12(h){ const v = h % 12; return v===0 ? 12 : v; }
function hourColor(hour){ return state.hours[(hour-1+12)%12] || '#ffffff'; }

let lastPairKey = '';
function regenGradient(){
  const now = new Date();
  const cur = h12(now.getHours());
  const next = cur % 12 + 1;
  const key = cur + '>' + next + ':' + hourColor(cur) + '→' + hourColor(next);
  if(key !== lastPairKey){
    makeGradientImage(hourColor(cur), hourColor(next));
    lastPairKey = key;
  }
}

function slideLoop(){
  const now = new Date();
  const vw = window.innerWidth;

  // smooth progress across the hour, 0→1
  const t = ((now.getMinutes()*60 + now.getSeconds())*1000 + now.getMilliseconds()) / 3600000;

  // center travels right→left
  const desiredCenter = (1 - t) * vw;                // px from left
  const leftOffset = desiredCenter - imgHalf;        // allow sub-pixel

  document.body.style.backgroundPosition = `${leftOffset}px 0px`;

  // Rebuild at hour change (or when colours changed)
  regenGradient();

  requestAnimationFrame(slideLoop);
}

/* ===== Resize handling ===== */
let resizeTimer=null;
function onResize(){
  if(resizeTimer) cancelAnimationFrame(resizeTimer);
  resizeTimer = requestAnimationFrame(()=>{ lastPairKey=''; regenGradient(); });
}

/* ===== Boot ===== */
renderGrain();
regenGradient();
slideLoop();
addEventListener('resize', onResize);
</script>
</body>
</html>
